## 리뷰

---

### 오늘 할 일

- 팀 프로젝트 피드백 반영
- 스파크 강의
- 아키텍처 및 유즈케이스 설계

## 강의

### 1. **Spark Job 최적화**

- 핵심 개념: Spark 튜닝의 본질은 데이터에 맞춰 Job을 최적화하는 것.
- 병목 원인: 노드 간 통신(Shuffle)이 성능 저하의 가장 큰 원인.
- RDD vs DataFrame
    - RDD: Low-level 접근 가능, 커스텀 연산 및 메모리 최적화에 유리.
    - DataFrame: 고성능 컬럼 기반 저장 포맷 → Shuffle 빈도 감소.
- Parquet 특징
    - 컬럼 단위 저장(Column-based) → 동일 타입 데이터 밀집, 읽기 성능 우수.
    - Schema Evolution 시 컬럼 추가 비용 큼.
    - WORM(Write Once, Read Many) 패턴에 최적.
    - 전체 행 연산에는 CSV/JSON이 더 유리할 수 있음.
- Spark 메모리 구조
    - 완전 in-memory가 아니라 LRU Cache 활용.
    - User Memory에 Lineage 저장.
- Shuffle 최소화 전략
    - `sortWithinPartition`, `repartitionByRange`로 파티션 내 정렬 후 합침.
    - 데이터 특성에 따라 파티션 조정.
- Cache / Persist / Checkpoint
    - cache: 메모리에만 저장, 같은 DAG 내 재사용.
    - persist: 메모리 또는 디스크 저장 가능.
    - checkpoint: Lineage 제거 후 RDD 자체 저장, 긴 작업·ML에서 활용.
- 성능 튜닝 요소
    - 파티션 수를 CPU 코어 수보다 데이터 특성 기준으로 조정.
    - `coalesce`: 작은 파티션 병합.
    - Skew 처리: `repartition`(splitting), salting.
    - broadcast join: 작은 데이터셋을 모든 노드에 전송해 Shuffle 최소화.
- Driver Web UI / History Server
    - Driver Web UI: 실행 중 Job의 리소스·병목 분석.
    - History Server: 완료된 Job 로그 기반 분석(제한적).

<aside>
💡

**Spark가 메모리보다 더 큰 데이터셋을 불러올 때 어떻게 처리를 하는가?**

- Storage Memory보다 더 큰 RDD를 읽는 경우
    - LRU 정책을 적용하여 덜 사용된 RDD 블록을 메모리에서 제거
- Execution Memory보다 더 큰 연산이 발생하는 경우
    - 현재 메모리에 있는 중간 연산 결과를 임시 파일로 디스크에 저장하고 나머지 데이터를 계속 메모리에 채워 연산 수행
</aside>

---

### 2. **데이터 저장소 개념**

- **Data Warehouse**: 목적 있는 의사결정용 데이터 중앙 집중 관리.
- **Data Lake**: 목적 없이 원천 데이터 저장 → 필요 시 변환 후 Warehouse 적재(ELT 배경).
- **Data Lakehouse**: Lake + Warehouse 장점 결합.

---

## **팀 활동 피드백**

- **문제 정의 시 관점 명확화**
    - Pros/Cons, 고통 크기 판단은 누구의 관점인지가 중요.
    - 피해자가 직접 부담하는 경우(예: 가해자 입장)로 범위를 좁혀 구체화.
- 유즈케이스 구체화
    - 견적서 평가 → 과잉 정비 시 사용자는 재견적 요청.
    - 연속된 재견적에서도 가격/수준이 수용 가능하면 중단 가능.
    - 이를 Activity Diagram으로 시각화.

---

### **견적 평가 Activity Diagram 흐름**

1. 견적서 제출 → 견적 평가
2. 평가 결과:
    - 과잉 정비 → 사용자 재검토 → 다른 정비소 추천 → 새 견적 평가
    - 사용자 검토 필요 → 다른 정비소 추천 여부 결정
    - 최적 정비 → 바로 비교/결정
3. 견적 비교 → 정비 결정(종료)

## 회고

---

### Keep

- 프로젝트를 설명할 때 시스템 아키텍처뿐만 아니라 Activity Diagram까지 설계하여, 머릿속 아이디어를 보다 구체적이고 시각적으로 표현할 수 있었음.

### Problem

### Try

- 소프트웨어 공학에서 사용하는 다양한 다이어그램(예: 시퀀스 다이어그램, 상태 다이어그램, 클래스 다이어그램 등)을 추가로 시도하여 표현 방식을 확장해보고 싶다.
