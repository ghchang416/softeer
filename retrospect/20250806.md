---

### 오늘 할 일

- 아이디어 취합 → 구체화 (오전)
- AWS 강의 (오후 2-4시)
- 아이디어 구체화 → 피드백
- W5M2 수행

### AWS 강의

**AWS에서 제공하는 Serverless**

: 서버가 없다는 것이 아니라 사용자가 서버 관리를 직접 하지 않는 것

1. lambda
    - handler 함수를 정의하여 연산을 처리할 수 있다.
        - param: event(input을 받는 도구 = json 구조), context(aws request)
        - stdout은 output console에 출력된다. 하지만 이를 계속해서 직접 확인하는 것은 힘들기 때문에 log는 cloud watch logs에 연결하여 볼 수 있다.
            - 하지만 바로 쓸 수는 없다 (IAM을 통해 권한 부여해야 함)
            - How? Role을 부여. cloud watch logs 외에도 다른 DB, S3와 같은 서비스에 접근하기 위해서는 해당 서비스에 대한 권한도 policy를 부여하면 된다.
            - IAM이 lambda를 호출하는 서비스에도 권한이 있는지 확인한다.
        - lambda는 stateless하다. 상태를 저장하기 위해 Remote(DB, cache)에 저장해야 한다.
            - `/root/tmp`에 임시 파일을 저장할 수 있다. `return` 을 만나기 전(런타임이 살아있을 때)는 임시 저장한 파일에 접근이 가능하지만, 다시 작업을 시작할 때 그 파일에 다시 접근할 수 있을지는 보장되지 않는다.
        - lambda의 비용과 시간은 trade-off 관계에 있다.
            - 하지만, 일정 비용 이상부터는 코드 layer에서 성능을 개선하지 않는 한 좋아지지 않는다.
            - 코드가 메모리나 성능 측면에서 최적화되어 있는지 단계별로 측정해야 한다.
2. API Gateway
    - controller code를 짤 때 api method의 부분을 api gateway가 맡게되고, 그 밑에 실행되는 로직을 lambda(예)가 가져가게 된다. 이 두개의 조합으로 serverless 구조의 api server를 하나 띄우는 것
    - 접근하는 사용자 입장에서는 그냥 백엔드 서버로 보인다
3. S3
4. DynamoDB
    - database를 생성하지 않고 바로 table로 접근한다.
        - row, column이 아니라, item attribute로 표기한다.
    - primary key → partition key로 부르고, 보조 키를 sort key라 부른다.
        - sort key를 같이 사용할 경우에는 partition key가 중복될 수 있다.
        - partition key에 따라 블록 단위로 나뉘어 있고 블록 내에서는 sort key로 정렬되어 있다.
    - secondary Index
        - local: partition key가 원본과 같음 → table 생성 시에만 만들 수 있음
        - global: partition key가 원본가 다름 → 아무때나 만들 수 있음
    - cache(DAX)
        - 기존에 redis를 사용한다고 하면, 캐시를 찌르고 캐시에 정보가 없으면 DB에 접근하여 정보를 가져오고 그것을 다시 캐시 서버에 정보를 넣어야 한다.
        - 하지만 dynamoDB에서는 DB를 찌르면 자동으로 DAX를 찌르게 되어 있다. 뒷단에 위의 로직이 수행되고 그것이 사용자에게는 간단하게 처리된다.
    
    **읽기/쓰기 일관성**
    
    - CAP 이론
        - Consistency
        - Availability
        - Partition tolerance
            - 분산 환경이면 무조건 선택해야 함.
    - 분산 환경이라면 CAP중 두 개만 고를 수 있다. (C or A 둘 중 하나는 포기)
    - CP: 무슨 일이 있어도 최신 값을 내놓겠다. (지연이 발생하더라도) → 강력한 일관성
    - AP: 무슨 일이 있어도 일단 값은 내놓겠다 (최신 값을 보장하지는 않음 / 서버가 죽지 않겠다) → 최종 일관성
    - 최종 일관성이 강력한 일관성 보다 훨씬 더 적은 리소스를 사용한다. 읽기를 덜 함.
    - 저장공간 무제한

### 팀 활동

- **기존 아이디어에 매몰되지 않고, 교통/모빌리티 전반에서 출발해 문제를 구체화해나가는 방향**으로 전환하기로 결정
- 기존에 기각했던 아이디어인 "**지역별 주정차 민원·불편 지도 API**"가 실현 가능성이 있다는 피드백을 받고, 다시 발전시키기로 함
- 다양한 아이디어를 **타임 박싱하여 병렬적으로 탐색**하되, 동시에 **유망한 아이디어에 대해선 프로토타이핑을 병행**하기로 함

**아이디어 진화 흐름**

| 구 아이디어 | 한계점 | 전환 후 방향성 |
| --- | --- | --- |
| 푸드트럭/택배차량이 단속을 피할 수 있는 주정차 가능 구간 탐색 | 상업성/공공성 부족, “단속을 피한다”는 부정적 인상 | 불법 주정차가 사회 안전을 위협하고 있음에 주목하여, CCTV 설치 우선순위 분석으로 전환 |

---

**문제 재정의**

- **문제 상황**:
    - 불법 주정차로 인한 응급차 진입 지연, 사고 다발, 교통 혼잡 등 피해 지속
    - CCTV 설치에 예산·인력 제한
- **핵심 문제**:
    - 단순 민원 건수만으로는 우선순위 판단이 어려움
    - 객관적인 기준 없이 설치하면 예산 낭비 가능성

---

**해결방안 방향성**

- 불법 주정차 민원 데이터 + 사고 데이터 + 단속 이력을 통합 분석
- 각 지역별 위험 스코어를 산정하고 GIS 기반 히트맵으로 시각화
- 지자체가 CCTV 설치 우선순위를 정량적으로 판단할 수 있도록 지원

---

**향후 계획**

- 의견 통합 및 비교 분석을 통해 가장 유효한 아이디어 선택
- 간단한 프로토타입 구현을 통해 문제 정의를 구체화할 예정
    - (오늘은 AWS 강의로 인해 실행하지 못했으나, 내일 중 시도 예정)

## 회고

---

### Keep

- 완벽한 아이디어는 처음부터 나올 수 없기에, 타임 박싱 안에서 도출된 아이디어 중 가장 나은 것을 선택해 우선 구체화해본 점은 잘한 결정이었다.
- 구체화 과정에서 처음에는 모호했던 개념들이 점점 명확해졌고, 문제 정의 또한 더 구체적으로 다듬어지고 있음.

### Problem

- 

### Try

- 사용자의 실제 문제를 더 잘 파악하기 위해, 해당 주제와 관련된 커뮤니티·SNS 등에서 텍스트 크롤링을 먼저 진행하고, 워드클라우드나 키워드 분석 등을 통해 주요 불편이나 이슈를 시각화해보는 접근을 시도해볼 가치가 있음.
    - 이렇게 사전 데이터를 분석한 뒤, 어떤 사용자 그룹이 어떤 상황에서 어떤 문제를 겪는지를 역으로 추론하는 방식도 문제 정의를 더 정교하게 만들어줄 수 있음.
